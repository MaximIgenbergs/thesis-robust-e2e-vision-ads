from __future__ import annotations

"""
Frame-based data utilities for DAVE2 training.

Generated by ChatGPT.
"""

import json
import os
import random
from typing import Iterator, List, Tuple

import numpy as np
from PIL import Image
from scripts.udacity.models.dave2.config import INPUT_SHAPE, NUM_OUTPUTS, VAL_SPLIT, RANDOM_SEED, BATCH_SIZE


def find_images(data_dir: str) -> List[str]:
    data_dir = os.path.expanduser(data_dir)
    hits: List[str] = []
    for root, _, files in os.walk(data_dir):
        for name in files:
            if name.lower().endswith(".jpg"):
                hits.append(os.path.join(root, name))
    hits.sort()
    return hits


def json_path_for(image_path: str) -> str:
    base = os.path.basename(image_path)
    idx = os.path.splitext(base)[0].split("_")[-1]
    return os.path.join(os.path.dirname(image_path), f"record_{idx}.json")


def load_image(path: str) -> np.ndarray:
    row, col, ch = INPUT_SHAPE
    im = Image.open(path)
    if im.size != (col, row):
        im = im.resize((col, row), resample=Image.BILINEAR)
    arr = np.asarray(im, dtype=np.float32)
    if arr.ndim == 2:
        arr = np.stack([arr] * 3, axis=-1)
    return arr


def load_label(json_path: str) -> list[float]:
    with open(json_path, "r", encoding="utf-8") as f:
        d = json.load(f)

    steer = float(d.get("user/angle", d.get("user/angel", 0.0)))
    throttle = float(d.get("user/throttle", 0.0))

    if NUM_OUTPUTS == 1:
        return [steer]

    return [steer, throttle]


def shuffle_in_place(files: List[str]) -> None:
    rng = random.Random(RANDOM_SEED)
    rng.shuffle(files)


def make_filelists(data_dir: str, val_split: float = VAL_SPLIT) -> Tuple[List[str], List[str]]:
    images = find_images(data_dir)
    if not images:
        return [], []

    shuffle_in_place(images)

    n_val = max(1, int(len(images) * val_split))
    val_files = images[:n_val]
    train_files = images[n_val:]
    return train_files, val_files


def data_generator(files: List[str], batch_size: int = BATCH_SIZE) -> Iterator[Tuple[np.ndarray, np.ndarray]]:
    row, col, ch = INPUT_SHAPE
    i = 0
    n = len(files)

    while True:
        batch_images: list[np.ndarray] = []
        batch_labels: list[list[float]] = []

        for _ in range(batch_size):
            if n == 0:
                break

            if i >= n:
                i = 0
                shuffle_in_place(files)

            image_path = files[i]
            i += 1

            json_path = json_path_for(image_path)
            if not os.path.exists(json_path):
                continue

            try:
                x = load_image(image_path)
                y = load_label(json_path)
            except Exception:
                continue

            batch_images.append(x)
            batch_labels.append(y)

        if not batch_images:
            continue

        x_batch = np.asarray(batch_images, dtype=np.float32)
        y_batch = np.asarray(batch_labels, dtype=np.float32)
        yield x_batch, y_batch
