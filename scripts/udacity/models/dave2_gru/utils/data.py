from __future__ import annotations

"""
Offline sequence builder for DAVE2-GRU.

Consumes per-frame Udacity-style logs:
  image:  x_cam-image_array_.jpg
  label:  record_x.json  with fields:
          { "user/angle": <float>, "user/throttle": <float>, "meta/track_id": <int>, "meta/frame": <int> }

Generated by ChatGPT.
"""

import json
import os
from typing import Dict, List, Tuple

import numpy as np
from PIL import Image

try:
    from scripts.udacity.models.dave2.config import INPUT_SHAPE as DAVE2_INPUT_SHAPE
    ROW, COL, CH = DAVE2_INPUT_SHAPE
except Exception:
    ROW, COL, CH = 120, 160, 3


def load_json(path: str) -> dict:
    with open(path, "rt", encoding="utf-8") as f:
        return json.load(f)


def infer_track_id(image_path: str, meta: dict) -> int:
    for key in ("meta/track_id", "track_id", "meta:track_id"):
        if key in meta:
            tid = meta[key]
            try:
                return int(tid)
            except Exception:
                pass

    parent = os.path.basename(os.path.dirname(image_path))
    if parent.startswith("track_"):
        try:
            return int(parent.split("_", 1)[1])
        except Exception:
            pass

    return 0


def frame_index(image_path: str, meta: dict) -> int:
    for key in ("meta/frame", "frame", "frame_index"):
        if key in meta:
            try:
                return int(meta[key])
            except Exception:
                pass

    base = os.path.basename(image_path)
    stem, _ = os.path.splitext(base)
    try:
        return int(stem.split("_")[-1])
    except Exception:
        return -1


def find_images(data_dir: str) -> List[str]:
    data_dir = os.path.expanduser(data_dir)
    out: List[str] = []
    for root, _, files in os.walk(data_dir):
        for name in files:
            if name.lower().endswith(".jpg"):
                out.append(os.path.join(root, name))
    out.sort()
    return out


def load_image(path: str) -> np.ndarray:
    im = Image.open(path)
    if im.size != (COL, ROW):
        im = im.resize((COL, ROW), resample=Image.BILINEAR)
    arr = np.asarray(im, dtype=np.float32)
    if arr.ndim == 2:
        arr = np.stack([arr] * 3, axis=-1)
    return arr


def build_sequences(
    data_dir: str,
    seq_len: int,
    stride: int = 1,
    expect_outputs: int = 2,
    drop_last_incomplete: bool = True,
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Build sequence tensors (X, y) from a directory of Udacity logs.

    X.shape = (N, T, ROW, COL, CH)
    y.shape = (N, expect_outputs)
    """
    image_paths = find_images(data_dir)
    if not image_paths:
        x_empty = np.empty((0, seq_len, ROW, COL, CH), np.float32)
        y_empty = np.empty((0, expect_outputs), np.float32)
        return x_empty, y_empty

    by_track: Dict[int, List[Tuple[int, str, dict]]] = {}

    for img in image_paths:
        frame_no = os.path.basename(img).split("_")[-1].split(".")[0]
        json_path = os.path.join(os.path.dirname(img), f"record_{frame_no}.json")
        if not os.path.exists(json_path):
            continue

        meta = load_json(json_path)
        tid = infer_track_id(img, meta)
        idx = frame_index(img, meta)
        by_track.setdefault(tid, []).append((idx, img, meta))

    for tid in by_track:
        by_track[tid].sort(key=lambda tup: tup[0])

    xs: List[np.ndarray] = []
    ys: List[np.ndarray] = []

    for frames in by_track.values():
        n = len(frames)
        if n < seq_len:
            continue

        end = n - (0 if drop_last_incomplete else (seq_len - 1))
        for start in range(0, end, stride):
            window = frames[start:start + seq_len]
            if len(window) < seq_len:
                break

            images = [load_image(p) for (_, p, __) in window]
            _, _, last_meta = window[-1]

            steer = float(last_meta.get("user/angle", last_meta.get("user/angel", 0.0)))
            throttle = float(last_meta.get("user/throttle", 0.0))

            if expect_outputs == 1:
                y = np.array([steer], dtype=np.float32)
            else:
                y = np.array([steer, throttle], dtype=np.float32)

            xs.append(np.stack(images, axis=0))
            ys.append(y)

    if not xs:
        x_empty = np.empty((0, seq_len, ROW, COL, CH), np.float32)
        y_empty = np.empty((0, expect_outputs), np.float32)
        return x_empty, y_empty

    x = np.stack(xs, axis=0).astype(np.float32)
    y = np.stack(ys, axis=0).astype(np.float32)
    return x, y
